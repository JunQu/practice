class Unionfind {
  parents: number[]
  rank: number[]

  constructor(size: number) {
    this.parents = Array(size)
      .fill(2)
      .map((_, index) => index)
    this.rank = Array(size).fill(1)
  }

  find(idx: number): number {
    if (this.parents[idx] !== idx) {
      this.parents[idx] = this.find(this.parents[idx])
    }
    return this.parents[idx]
  }

  union(idxA: number, idxB: number) {
    const parentA = this.find(idxA)
    const parentB = this.find(idxB)

    if (parentA === parentB) {
      return
    }

    if (this.rank[parentA] >= this.rank[parentB]) {
      this.parents[parentB] = parentA
      this.rank[parentA] += this.rank[parentB]
    } else {
      this.parents[parentA] = parentB
      this.rank[parentB] += this.rank[parentA]
    }
  }

  getSize(idx: number) {
    return this.rank[this.find(idx)]
  }
}

export const minMalwareSpread = (graph: number[][], initial: number[]): number => {
  if (initial.length === 1) {
    return 0
  }
  const size = graph.length
  const uf = new Unionfind(size)

  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      if (j === i) {
        continue
      }
      if (graph[i][j] === 1) {
        uf.union(i, j)
      }
    }
  }

  const count = Array(size).fill(0)
  // 统计每个连通分量的感染的点数
  for (const num of initial) {
    const parent = uf.find(num)
    count[parent] += 1
  }

  let maxSize = 1
  let index = -1
  // 寻找只有单独一个的连接点,因为只有一个，如果超过一个，删除和不删除没区别
  for (const num of initial) {
    const parent = uf.find(num)
    const size = uf.getSize(parent)

    if (count[parent] === 1 && size >= maxSize) {
      maxSize = size
      index = index === -1 || num < index ? num : index
    }
  }

  return index !== -1 ? index : Math.min(...initial)
}
